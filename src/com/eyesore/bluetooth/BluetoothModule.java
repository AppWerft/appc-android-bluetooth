/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.eyesore.bluetooth;

import java.util.Collections;
import java.util.Set;

import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiBlob;

import android.bluetooth.BluetoothDevice;

import android.os.IBinder;
import android.os.ParcelUuid;

import android.content.Intent;
import android.content.Context;
import android.content.ServiceConnection;
import android.content.ComponentName;

import android.app.Activity;

import com.eyesore.bluetooth.BluetoothService;


@Kroll.module(name="Bluetooth", id="com.eyesore.bluetooth")
public class BluetoothModule extends KrollModule
{

	// Standard Debugging variables
	private static final String LCAT = "BluetoothModule";
	private static final boolean DBG = TiConfig.LOGD;

	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;
	private final String DISCOVERY_FINISHED = "bluetooth:discovery";
	private final String SERVICES_FOUND = "bluetooth:services";
	private final String DATA_RECEIVED = "bluetooth:data:";
	private final String MESSAGE_EVENT = "bluetooth:message";
	private final String DEVICE_PAIRED = "bluetooth:paired";
	private final String ERROR_EVENT = "bluetooth:error";
	
	public static BluetoothService mBluetooth;
	private static Context mContext;
	
	public ComponentName className = new ComponentName("com.eyesore.bluetooth", "BluetoothModule");
	
	private static ServiceConnection mConnection;
	private KrollDict mDevices;
	
	public BluetoothModule()
	{
		super();
		final BluetoothModule self = this;  // here's to javascript
		TiApplication appContext = TiApplication.getInstance();
		Activity currentActivity = appContext.getCurrentActivity();
		mContext = currentActivity.getBaseContext();
		
		mBluetooth = new BluetoothService(mContext);
		
		Intent i = new Intent(mContext, BluetoothService.class);		
		
		mConnection = new ServiceConnection(){
			@Override
			public void onServiceConnected(ComponentName className, IBinder binder) {
				Log.d(LCAT,  "Successfully bound bluetooth service.");
				mBluetooth.registerReceivers();
				mBluetooth.setBluetoothModule(self);
			}

			@Override
			public void onServiceDisconnected(ComponentName className) {
				disposeService();
			}
		};	
		
		Log.d(LCAT,  "About to bind service");
		mContext.bindService(i, mConnection, Context.BIND_AUTO_CREATE);
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app)
	{
		Log.d(LCAT, "inside onAppCreate");
		// put module init code that needs to run when the application is created
	}
	
	// Public Methods
	@Kroll.method
	public void requestEnable()
	{
		Log.d(LCAT,  "Attempting to enable bluetooth");
        mBluetooth.connectBluetooth();
	}
	
	@Kroll.method
	public void findDevices()
	{
		Log.d(LCAT, "findBluetoothDevices called");
		
		// initialize deviceSet to previously bonded devices
		//mDeviceSet = mBluetooth.findBondedDevices();  // since we can't use devices that aren't in range, for now we'll just make an empty set
		mBluetooth.findBluetoothDevices();
	}
	
	@Kroll.method
	public void getDeviceServices(String deviceName)
	{
		mBluetooth.getServiceList(getAddress(deviceName));
	}
	
	@Kroll.method
	public void pairDevice(String deviceName, String serviceName)
	{
		mBluetooth.attemptConnection(getAddress(deviceName), serviceName);
	}
	
	/**
	 * This should be implemented in a setTimeout (or similar) in the application
	 * to prevent the BluetoothServerSocket.accept() call to continue indefinitely.
	 * This would rapidly drain device power.
	 */
	@Kroll.method
	public void abortPairing(String device)
	{
		mBluetooth.abortPairing(getAddress(device));
	}
	
	@Kroll.method
	public void stopService()
	{
		disposeService();
	}
	
//	@Kroll.method
//	public void getBondedDevices()
//	{
//		Set<BluetoothDevice> devices = mBluetooth.findBondedDevices();
//		for(BluetoothDevice d : devices)
//		{
//			Log.d(LCAT, d.getName());
//			ParcelUuid[] parcels = d.getUuids();  // API 15 or higher only
//			for(ParcelUuid p : parcels)
//			{
//				Log.d(LCAT, p.getUuid().toString());
//			}
//			Log.d(LCAT, "Bond state: " + d.getBondState());
//		}
//	}
	
	/**
	 * This will fire an event containing any devices found during discovery, 
	 * as well as any devices that have been previously paired, regardless of whether
	 * they are connected or even available.
	 * 
	 * @param devices Array of Bluetooth Devices found during discovery.
	 */
	public void discoveryFinished(BluetoothDevice[] devices)
	{
		KrollDict allDevices = new KrollDict();
		//Set<BluetoothDevice> bondedDevices = mBluetooth.findBondedDevices();
		
		// add discovered devices to availableDevices
		for(Integer j = 0; j < devices.length; j++)
		{
			if(devices[j] != null && !allDevices.containsKey(devices[j]))
			{
				try{
					mBluetooth.startSdp(devices[j]);
				}
				catch(Exception e){
					e.printStackTrace();
					sendError(e.getMessage());
				}
				allDevices.put(devices[j].getName(), devices[j].getAddress());
			}
		}
		
		// make sure it's a new Dict every time discovery occurs
		mDevices = allDevices;
		
		KrollDict props = new KrollDict();
		props.put("devices", mDevices);
		
		fireEvent(DISCOVERY_FINISHED, props);
	}
	
	public void servicesFound(String[] services)
	{
		KrollDict props = new KrollDict();
		props.put("services", services);
		
		fireEvent(SERVICES_FOUND, props);
	}
	
	public void dataReceived(String source, byte[] data)
	{
		TiBlob blob = TiBlob.blobFromData(data);
		KrollDict props = new KrollDict();
		props.put("data", blob);
		Log.d(LCAT, "Firing event: " + DATA_RECEIVED + source);
		fireEvent(DATA_RECEIVED + source, props);
		Log.d(LCAT, "Message sent!");
	}
	
	public void devicePaired(String deviceName)
	{
		KrollDict props = new KrollDict();
		props.put("device", deviceName);
		
		fireEvent(DEVICE_PAIRED, props);
	}
	
	public void sendMessage(String message)
	{
		KrollDict props = new KrollDict();
		props.put("message", message);
		
		fireEvent(MESSAGE_EVENT, props);
	}
	
	public void sendError(String message)
	{
		KrollDict props = new KrollDict();
		props.put("message", message);
		
		fireEvent(ERROR_EVENT, props);
	}
	
	private String getAddress(String deviceName)
	{
		String deviceAddress = (String) mDevices.get(deviceName);
		return deviceAddress;
	}
	
	private void disposeService()
	{
		mBluetooth.closeAllConnections(); 
		Intent i = new Intent(mContext, BluetoothService.class);
		mContext.unbindService(mConnection);
		mContext.stopService(i);
		mBluetooth.unregisterReceivers();
		mBluetooth = null;
	}
}