/*
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package com.eyesore.bluetooth;

import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;

import org.appcelerator.titanium.TiApplication;
import org.appcelerator.titanium.TiBlob;

import android.bluetooth.BluetoothDevice;

import android.os.IBinder;

import android.content.Intent;
import android.content.Context;
import android.content.ServiceConnection;
import android.content.ComponentName;

import android.app.Activity;

import com.eyesore.bluetooth.BluetoothService;


@Kroll.module(name="Bluetooth", id="com.eyesore.bluetooth")
public class BluetoothModule extends KrollModule
{

	// Standard Debugging variables
	private static final String LCAT = "BluetoothModule";
	private static final boolean DBG = TiConfig.LOGD;

	// You can define constants with @Kroll.constant, for example:
	// @Kroll.constant public static final String EXTERNAL_NAME = value;
	private final String DISCOVERY_FINISHED = "bluetooth:discovery";
	private final String SERVICES_FOUND = "bluetooth:services";
	private final String DATA_RECEIVED = "bluetooth:data:";
	private final String MESSAGE_EVENT = "bluetooth:message";
	private final String DEVICE_PAIRED = "bluetooth:paired";
	private final String ERROR_EVENT = "bluetooth:error";
	private final String APP_DESTROY = "bluetooth:destroy";
	private final String APP_START = "bluetooth:start";
	private final String APP_STOP = "bluetooth:stop";
	private final String APP_PAUSE = "bluetooth:pause";
	private final String APP_RESUME = "bluetooth:resume";
	
	private BluetoothService mBluetooth = null;
	private final Context mContext;
	
	public ComponentName className = new ComponentName("com.eyesore.bluetooth", "BluetoothModule");
	
	private ServiceConnection mConnection;
	private KrollDict mDevices;
	
	// by default, stop the bluetooth service when the app exits
	private Boolean KillOnDestroy = true;
	
	//  CONSTANTS EXPOSED PUBLICLY
//	@Kroll.constant
//	public static final int IOEXCEPTION = 1;
	
	/**
	 * @class BluetoothModule
	 * @constructor
	 * @return {BluetoothModule} The bluetooth namespace.
	 */
	public BluetoothModule()
	{
		super();
		TiApplication appContext = TiApplication.getInstance();
		Activity currentActivity = appContext.getCurrentActivity();
		mContext = currentActivity.getBaseContext();
		startService();
	}

//	@Kroll.onAppCreate
//	public static void onAppCreate(TiApplication app)
//	{
//		// put module init code that needs to run when the application is created
//	}
	
	/**
	 * Fires when the module activity is destroyed.  Receives the native android onDestroy event.
	 * Be sure to understand the android activity lifecycle before attempting to use.
	 * See http://developer.android.com/reference/android/app/Activity.html
	 * @event bluetooth:destroy 
	 * @since 1.2
	 */
	@Override
	public void onDestroy(Activity activity)
	{
		Log.d(LCAT, "Received native destroy event.");
		fireEvent(APP_DESTROY, new KrollDict());
		
		if(KillOnDestroy)
			stopService();
	}
	
	/**
	 * Fires when the native android onStart event is received by the module.
	 * Be sure to understand the android activity lifecycle before attempting to use.
	 * See http://developer.android.com/reference/android/app/Activity.html
	 * @event bluetooth:start 
	 * @since 1.2
	 */
	@Override
	public void onStart(Activity activity)
	{
		Log.d(LCAT, "Received native start event.");
		fireEvent(APP_START, new KrollDict());
	}
	
	/**
	 * Fires when the native android onStop event is received by the module.
	 * Be sure to understand the android activity lifecycle before attempting to use.
	 * See http://developer.android.com/reference/android/app/Activity.html
	 * @event bluetooth:stop
	 * @since 1.2
	 */
	@Override
	public void onStop(Activity activity)
	{
		Log.d(LCAT, "Received native stop event.");
		fireEvent(APP_STOP, new KrollDict());
	}
	
	/**
	 * Fires when the native android onPause event is received by the module.
	 * Be sure to understand the android activity lifecycle before attempting to use.
	 * See http://developer.android.com/reference/android/app/Activity.html
	 * @event bluetooth:pause 
	 * @since 1.2
	 */
	@Override
	public void onPause(Activity activity)
	{
		Log.d(LCAT, "Received native pause event.");
		fireEvent(APP_PAUSE, new KrollDict());
	}
	
	/**
	 * Fires when the native android onResume event is received by the module.
	 * Be sure to understand the android activity lifecycle before attempting to use.
	 * See http://developer.android.com/reference/android/app/Activity.html
	 * @event bluetooth:resume 
	 * @since 1.2
	 */
	@Override
	public void onResume(Activity activity)
	{
		Log.d(LCAT, "Received native resume event.");
		fireEvent(APP_RESUME, new KrollDict());
	}
	
	/**
	 * Start the bluetooth service controlled by the module.  This is called by the constructor, so it shouldn't be
	 * necessary to call it unless the service is stopped manually.  It is safe to call this method while the service
	 * is running.  In that case, it will have no effect.  Calling any other methods while the service is not running
	 * will result in an error.
	 * 
	 * @method startService
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void startService()
	{
		if(mBluetooth != null)
		{
			sendMessage("Service is already running.");
			Log.d(LCAT, "Service is already running.");
			return;
		}
		
		mBluetooth = new BluetoothService(mContext);
		mBluetooth.setBluetoothModule(this);
				
		Intent i = new Intent(mContext, BluetoothService.class);		
		
		mConnection = new ServiceConnection(){
			@Override
			public void onServiceConnected(ComponentName className, IBinder binder) {
				mBluetooth.registerReceivers();
			}
	
			@Override
			public void onServiceDisconnected(ComponentName className) {
				disposeService();
			}
		};	
	
		mContext.bindService(i, mConnection, Context.BIND_AUTO_CREATE);
		Log.d(LCAT, "Bluetooth service started.");
	}
	
	/**
	 * Request that the Android OS enable the device's bluetooth radio (if one exists).  A message will be sent back via
	 * the "bluetooth:message" event regarding the status of the request.  Safe to call if bluetooth is already enabled.
	 * If not, the user will be prompted to allow bluetooth to be enabled.
	 * 
	 * @method requestEnable
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void requestEnable()
	{
		Log.d(LCAT,  "Attempting to enable bluetooth");
        mBluetooth.connectBluetooth();
	}
	
	/**
	 * Check if the device's bluetooth adapter is enabled.
	 * @method isEnabled
	 * @return Boolean
	 * @since 1.1
	 */
	@Kroll.method
	public Boolean isEnabled()
	{
		return mBluetooth.isEnabled();
	}
	
	/**
	 * Check if the device has a bluetooth adapter.
	 * @method isSupported
	 * @return Boolean
	 * @since 1.2
	 */
	@Kroll.method
	public Boolean isSupported()
	{
		return mBluetooth.isSupported();
	}
	
	/**
	 * Start the remote device discovery process.  From android developer reference:
	 * "The discovery process usually involves an inquiry scan of about 12 seconds, followed by a page scan
	 * of each new device to retrieve its Bluetooth name."
	 * Devices found will be returned asynchronously via the "bluetooth:discovery" event.
	 * 
	 * @method findDevices
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void findDevices()
	{
		mBluetooth.findBluetoothDevices();
	}
	
	/**
	 * Retrieve the names of services that the remote device may use to connect.  These are returned asynchronously
	 * via the "bluetooth:services" event.  You must pass the name of a service that the remote device supports in order to
	 * pair with it.  Unless there is a particular service that you need to connect to, you will probably have the most
	 * success just using "Serial Port".
	 * 
	 * @method getDeviceServices
	 * @param deviceName {string} The name of the device to query, as returned in the "bluetooth:discovery" event.
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void getDeviceServices(String deviceName)
	{
		mBluetooth.getServiceList(getAddress(deviceName));
	}
	
	/**
	 * Initiate a connection to the remote device on the specified channel.  In some cases you must confirm this
	 * connection on the remote device, or with a PIN, and you will be prompted to do so.  After pairing is complete, data transfer may
	 * begin immediately.  The event "bluetooth:paired" is fired when pairing has completed successfully.
	 * 
	 * @method pairDevice
	 * @param deviceName {string} The name of the device with which to pair, as returned in the "bluetooth:discovery" event.
	 * @param serviceName {string} The name of the remote service (channel) to connect to as returned in the "bluetooth:services" event.
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void pairDevice(String deviceName, String serviceName)
	{
		mBluetooth.attemptConnection(getAddress(deviceName), serviceName);
	}
	
	/**
	 * Connect to the bluetooth serial-port-like service without need for querying device services.  
	 * This should work for most devices.
	 * @method quickPair
	 * @param deviceName {string} The name of the device with which to pair, as returned in the "bluetooth:discovery" event.
	 * @return void
	 * @since 1.2
	 */
	@Kroll.method
	public void quickPair(String deviceName)
	{
		pairDevice(deviceName, "SerialPort");
	}
	
	/**
	 * Close the remote and local sockets that have been opened for pairing for the given device.  If pairing is in process, this will 
	 * stop it, otherwise it won't do anything. This should be implemented in a setTimeout (or similar) in the application
	 * to prevent the BluetoothServerSocket.accept() call to continue indefinitely, which would rapidly drain device power.
	 * 
	 * @method abortPairing
	 * @param device {string} The name of the device with which to terminate pairing, as returned in the "bluetooth:discovery" event.
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void abortPairing(String device)
	{
		mBluetooth.abortPairing(getAddress(device));
	}
	
	/**
	 * Close an open data connection to the given device (after pairing has finished).  This will cause the device to be disconnected.
	 * 
	 * @method abortConnection
	 * @param device {string} The name of the device with which to terminate the connection, as returned in the "bluetooth:discovery" event.
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void abortConnection(String device)
	{
		mBluetooth.stopBluetoothThreads(getAddress(device));
	}
	
	/**
	 * Optionally set the size of the output buffer.  Default is 8192 bytes.  Outgoing data will be added to 
	 * the buffer until full, then the buffer will be flushed.
	 * @method setOutputBuffer
	 * @param bytes {number} Size of the output buffer in bytes.  Defaults to 8192.
	 * @return void
	 * @since 1.1
	 */
	@Kroll.method
	public void setOutputBuffer(Integer bytes)
	{
		mBluetooth.setOutputBuffer(bytes);
	}
	
	/**
	 * Optionally set the size of the input buffer.  Default is 8192 bytes.  Incoming data will be added to 
	 * the buffer until full, then the buffer will be flushed.
	 * @method setInputBuffer
	 * @param bytes {number} Size of the input buffer in bytes.  Defaults to 8192 bytes.
	 * @return void
	 * @since 1.1
	 */
	@Kroll.method
	public void setInputBuffer(Integer bytes)
	{
		mBluetooth.setInputBuffer(bytes);
	}
	
	/**
	 * Optionally set the size of the output buffer.  Default is 1024 bytes.  This is the maximum size of the Titanium.Blob returned in
	 * each "bluetooth:data:deviceName" event.  New buffer size applies only to connections made in the future.
	 * So in order to reconfigure the output buffer of a currently active connection, you would need to disconnect the device, set
	 * the buffer size, then reconnect.  Ideally this is set once, after starting the service, but it can be configured differently for
	 * each connection by calling setReadSize(bytes) before calling pairDevice.
	 * @method setReadSize
	 * @param bytes {number} Max size of data returned in each "data" event.  Defaults to 1024 bytes.
	 * @return void
	 * @since 1.1
	 */
	@Kroll.method
	public void setReadSize(Integer bytes)
	{
		mBluetooth.setReadSize(bytes);
	}
	
	/**
	 * Optionally set whether the bluetooth service is stopped automatiacally when the module activity is destroyed.
	 * Default it true;
	 * @method setKillOnDestroy
	 * @param b True or false
	 * @return void
	 * @since 1.2
	 */
	@Kroll.setProperty
	public void setKillOnDestroy(Boolean b)
	{
		KillOnDestroy = b;
	}
	
	/**
	 * Manually stop the bluetooth service.  If you don't call this when your app exits, the service will continue running in the background!
	 * 
	 * @method stopService
	 * @return void
	 * @since 1.0
	 */
	@Kroll.method
	public void stopService()
	{
		if(mBluetooth == null)
		{
			sendMessage("Bluetooth service is not running.");
			return;
		}
		
		disposeService();
	}
	
	/**
	 * Send raw data to a connected device.
	 * 
	 * @method write
	 * @param deviceName Name of the remote device.
	 * @param data Raw data to send.
	 * @return void
	 * @since 1.1
	 */
	@Kroll.method
	public void write(String deviceName, TiBlob data)
	{
		mBluetooth.write(getAddress(deviceName), data.getBytes());
	}
	
//	@Kroll.method
//	public void getBondedDevices()
//	{
//		Set<BluetoothDevice> devices = mBluetooth.findBondedDevices();
//		for(BluetoothDevice d : devices)
//		{
//			Log.d(LCAT, d.getName());
//			ParcelUuid[] parcels = d.getUuids();  // API 15 or higher only
//			for(ParcelUuid p : parcels)
//			{
//				Log.d(LCAT, p.getUuid().toString());
//			}
//			Log.d(LCAT, "Bond state: " + d.getBondState());
//		}
//	}
	
	/*
	 * This will fire an event containing any devices found during discovery, 
	 * as well as any devices that have been previously paired, regardless of whether
	 * they are connected or even available.
	 * 
	 * @param devices Array of Bluetooth Devices found during discovery.
	 */
	// begin yuidoc
	/**
	 * @event bluetooth:discovery
	 * @param devices {object} Keys are device names and values are hardware addresses.  Currently, only the name is used by this module.
	 * @since 1.0
	 */
	public void discoveryFinished(BluetoothDevice[] devices)
	{
		KrollDict allDevices = new KrollDict();
		//Set<BluetoothDevice> bondedDevices = mBluetooth.findBondedDevices();
		
		// add discovered devices to availableDevices
		for(Integer j = 0; j < devices.length; j++)
		{
			if(devices[j] != null && !allDevices.containsKey(devices[j]))
			{
				try{
					mBluetooth.startSdp(devices[j]);
				}
				catch(Exception e){
					e.printStackTrace();
					sendError(e.getMessage());
				}
				allDevices.put(devices[j].getName(), devices[j].getAddress());
			}
		}
		
		// make sure it's a new Dict every time discovery occurs
		mDevices = allDevices;
		
		KrollDict props = new KrollDict();
		props.put("devices", mDevices);
		
		fireEvent(DISCOVERY_FINISHED, props);
	}
	
	/**
	 * NB. When queried by the service discovery protocol, devices return the UUIDs of services that they claim to support.
	 * For the sake of human readability, these UUIDs have been mapped to names/descriptions, which is what this module uses to
	 * designate a service with which to connect.  The names should not necessarily be relied upon as accurate.  If you need to know
	 * the UUID, the mapping comes from here:
	 * http://bluetooth-pentest.narod.ru/doc/assigned_numbers_-_service_discovery.html
	 * 
	 * @event bluetooth:services
	 * @param services {array} Array of the names of services that the device claims to support.
	 * @since 1.0
	 */
	public void servicesFound(String[] services)
	{
		KrollDict props = new KrollDict();
		props.put("services", services);
		
		fireEvent(SERVICES_FOUND, props);
	}
	
	/**
	 * Transmits a package of data from the remote device to the host device.  Once a connection is established you should begin listening
	 * for this event.  The event name includes the name of the device in place of "deviceName".
	 * 
	 * @event bluetooth:data:deviceName
	 * @param data {Titanium.Blob} Binary data transmitted from the remote device.
	 * @since 1.0
	 */
	public void dataReceived(String source, byte[] data)
	{
		TiBlob blob = TiBlob.blobFromData(data);
		KrollDict props = new KrollDict();
		props.put("data", blob);

		fireEvent(DATA_RECEIVED + source, props);
	}
	
	/**
	 * Fires after successfully pairing with device.
	 * 
	 * @event bluetooth:paired
	 * @param device {string} The name of the device that is now paired.
	 * @since 1.0
	 */
	public void devicePaired(String deviceName)
	{
		KrollDict props = new KrollDict();
		props.put("device", deviceName);
		
		fireEvent(DEVICE_PAIRED, props);
	}
	
	/**
	 * Occasionally the module will have something to say.  Listen for it on this event.
	 * 
	 * @event bluetooth:message
	 * @param message {string} A message from the bluetooth module.
	 * @since 1.0
	 */
	public void sendMessage(String message)
	{
		KrollDict props = new KrollDict();
		props.put("message", message);
		
		fireEvent(MESSAGE_EVENT, props);
	}
	
	/**
	 * Identical to bluetooth:message, but more or less important, depending on your perspective.
	 * 
	 * @event bluetooth:error
	 * @param message {string} Something's gone terribly wrong.
	 * @since 1.0
	 */
	public void sendError(String message)
	{
		KrollDict props = new KrollDict();
		props.put("message", message);
		
		fireEvent(ERROR_EVENT, props);
	}
	
	// private  methods only below this point!
	
	private String getAddress(String deviceName)
	{
		String deviceAddress = (String) mDevices.get(deviceName);
		return deviceAddress;
	}
	
	private void disposeService()
	{
		mBluetooth.closeAllConnections(); 
		Intent i = new Intent(mContext, BluetoothService.class);
		mContext.unbindService(mConnection);
		mContext.stopService(i);
		mBluetooth.unregisterReceivers();
		mBluetooth = null;
	}
}